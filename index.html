<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>実車評価支援ツール（初期近傍読み上げ・終了時保存・CPメモ・速度/距離）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet：CDN -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>

  <style>
    html, body { height:100%; margin:0; }
    #map { position:absolute; inset:0; min-height:60vh; } /* 保険で高さ確保 */

    #panel{
      position:absolute; top:8px; left:8px; right:8px;
      background:#fff; padding:10px; border-radius:12px;
      box-shadow:0 2px 6px rgba(0,0,0,.3);
      z-index:1000; font-size:14px; max-width:560px;
    }
    h1{ margin:0 0 6px; font-size:14px; }
    .row{ display:flex; flex-wrap:wrap; gap:8px; margin:4px 0; align-items:center; }
    .grow{ flex:1; }
    button{ padding:6px 10px; border-radius:10px; border:1px solid #888; background:#f0f0f0; }
    #fabStop{ position:absolute; bottom:20px; right:20px; border-radius:50%; width:64px; height:64px; font-size:14px; font-weight:bold; background:red; color:#fff; display:none; z-index:1200; }
    .counts{ font-size:12px; margin-left:auto; }
    .small{ font-size:12px; color:#333; }

    @media (max-width:480px){
      #panel{ padding:8px 10px; border-radius:10px; font-size:12px; }
      h1{ font-size:13px; }
      button{ padding:6px 8px; min-height:32px; font-size:12px; }
      .row{ gap:6px; }
      .row.row-actions{ display:grid; grid-template-columns:1fr 1fr; gap:6px; }
      #fname{ display:none; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <h1>実車評価支援ツール</h1>

    <div class="row">
      <input type="file" id="file" accept=".kml,.kmz" multiple />
      <select id="datasetSelect" class="grow">
        <option value="" disabled selected>（読み込んだルート／ポイントを選択）</option>
      </select>
      <span id="fname" class="small"></span>
    </div>

    <div class="row row-actions">
      <button id="start">追跡開始</button>
      <button id="stop" disabled>追跡終了</button>
      <button id="recenter">現在地へ</button>
      <button id="cp" disabled>チェックポイント</button>
      <span id="counts" class="counts"></span>
    </div>

    <!-- ★ 速度/距離のHUD -->
    <div class="row small" id="hud" style="align-items:baseline;">
      <span>速度: <strong><span id="hudSpeed">0.0</span> km/h</strong></span>
      <span style="margin-left:12px;">距離: <strong><span id="hudDist">0.000</span> km</strong></span>
    </div>

    <details id="adv" open>
      <summary class="small">詳細設定</summary>

      <div class="row">
        <label><input type="checkbox" id="keepCentered" checked />自車を常に中心</label>
        <label style="margin-left:10px">向き:</label>
        <label><input type="radio" name="orient" value="north" checked />北を上</label>
        <label><input type="radio" name="orient" value="course" />進行方向を上</label>
      </div>

      <div class="row">
        <button id="tts">音声テスト</button>
        <button id="wake">画面オフ防止: OFF</button>
      </div>

      <div class="row">
        <label class="small" for="ttsRate">話す速度: <span id="ttsRateVal">1.0</span>x</label>
        <input id="ttsRate" type="range" min="0.6" max="1.6" step="0.1" value="1.0" style="width:180px; margin-left:8px;">
      </div>

      <div class="row">
        <label class="small" for="notifyRange">通知半径: <span id="notifyRangeVal">120</span> m</label>
        <input id="notifyRange" type="range" min="50" max="300" step="10" value="120" style="width:180px; margin-left:8px;">
      </div>
    </details>
  </div>

  <button id="fabStop">終了</button>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="jszip.min.js"></script>
  <script src="togeojson.umd.js"></script>

  <script>
  document.addEventListener('DOMContentLoaded', function(){

    /* ===== 地図 ===== */
    const map = L.map('map').setView([35.0, 135.0], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // 自車マーカー（赤塗り）
    const carIcon = L.divIcon({
      className: 'custom-car',
      html: '<div style="width:16px;height:16px;background:red;border-radius:50%;"></div>',
      iconSize: [16,16], iconAnchor: [8,8]
    });
    const carMarker = L.marker([35.0, 135.0], {icon:carIcon}).addTo(map);

    /* ===== TTS（iPhone設定に従う） ===== */
    const ttsRate = document.getElementById('ttsRate');
    const ttsRateVal = document.getElementById('ttsRateVal');
    function speak(text, onend){
      const u = new SpeechSynthesisUtterance(text);
      u.rate = parseFloat(ttsRate.value || '1.0');
      if (onend) u.onend = onend;
      speechSynthesis.speak(u);
    }
    document.getElementById('tts').addEventListener('click', ()=>{ speak('音声テストです。'); });
    ttsRate.addEventListener('input', ()=>{ ttsRateVal.textContent = ttsRate.value; });

    /* ===== 追跡 ===== */
    let watching = null;
    let tracking = false;
    let points = [];
    let lastPos = null;                     // 直近位置（読み上げ・再中心用）
    const cpList = [];                      // チェックポイント（メモ付き）
    const poly = L.polyline([], { color:'#d00', weight:4 }).addTo(map);

    // ★ 速度/距離 用
    let totalDistM = 0;                     // 累積距離[m]
    let lastTrackPoint = null;              // 前回トラック点 {lat, lon, t}
    let lastSpeedMps = 0;                   // 直近速度[m/s]
    const hudSpeed = document.getElementById('hudSpeed');
    const hudDist  = document.getElementById('hudDist');
    function fmt(n, d){ return (isFinite(n)? n : 0).toFixed(d); }
    function updateHUD(){
      if (hudSpeed) hudSpeed.textContent = fmt(lastSpeedMps * 3.6, 1);
      if (hudDist)  hudDist.textContent  = fmt(totalDistM / 1000, 3);
    }
    function resetTripStats(){
      totalDistM = 0;
      lastTrackPoint = null;
      lastSpeedMps = 0;
      updateHUD();
    }

    const startBtn = document.getElementById('start');
    const stopBtn  = document.getElementById('stop');
    const fabStop  = document.getElementById('fabStop');
    const recenterBtn = document.getElementById('recenter');
    const cpBtn = document.getElementById('cp');
    const keepCentered = document.getElementById('keepCentered');
    const counts = document.getElementById('counts');
    function updateCounts(){ counts.textContent = `点:${points.length}`; }

    // 初期まとめ読み上げ 制御（レース潰し）
    let initialAnnounced = false;   // 一度だけ
    let initialAnnouncing = false;  // 実行中は通常アナウンスを抑止

    function onLoc(pos){
      const { latitude:lat, longitude:lon, speed } = pos.coords; // speed: m/s (一部端末のみ)
      const now = Date.now();
      lastPos = {lat, lon};
      carMarker.setLatLng([lat, lon]);

      if (tracking){
        // 距離/速度の更新
        if (lastTrackPoint){
          const d = haversineMeters(lat, lon, lastTrackPoint.lat, lastTrackPoint.lon);
          const dt = Math.max(0.001, (now - lastTrackPoint.t) / 1000); // sec
          totalDistM += d;
          // 速度は coords.speed を優先。無ければ d/dt
          const sp = (typeof speed === 'number' && isFinite(speed) && speed >= 0) ? speed : (d / dt);
          lastSpeedMps = sp;
        } else {
          lastSpeedMps = (typeof speed === 'number' && isFinite(speed) && speed >= 0) ? speed : 0;
        }
        lastTrackPoint = { lat, lon, t: now };
        updateHUD();

        // トラック点の保存
        points.push({lat, lon, time: new Date(now).toISOString()});
        poly.addLatLng([lat, lon]);
        updateCounts();
      }

      if (keepCentered.checked) map.setView([lat, lon]);

      // 初期まとめ読み上げが終わるまでは通常アナウンス抑止
      if (tracking && !initialAnnounced) {
        tryAnnounceInitialOnce();
      } else {
        maybeAnnounceNearestPOI(lat, lon);
      }
    }
    function onLocErr(err){ console.warn(err); }

    function startTracking(){
      if (tracking) return;
      tracking = true;
      resetTripStats(); // ★ 開始時に距離/速度リセット
      points = [];      // 軌跡も新規開始（必要に応じて保持に変更可）
      updateCounts();

      startBtn.disabled = true; stopBtn.disabled = false; cpBtn.disabled = false;
      fabStop.style.display = 'block';

      speak('追跡を開始します。', ()=> {
        ensurePositionThenAnnounce();  // 位置取得→初期まとめ読み上げ
      });

      if (!watching) {
        watching = navigator.geolocation.watchPosition(
          onLoc, onLocErr, { enableHighAccuracy:true, maximumAge:2000, timeout:10000 }
        );
      }
      document.getElementById('adv').open = false;
    }

    async function stopTracking(){
      if (!tracking) return;
      tracking = false;
      startBtn.disabled = false; stopBtn.disabled = true; cpBtn.disabled = true;
      fabStop.style.display = 'none';
      speak('追跡を終了しました。');

      document.getElementById('adv').open = true;

      // ★ 終了後に保存確認 → YESならファイル名入力 → 保存
      if (points.length) {
        const ok = window.confirm('軌跡(GPX)を保存しますか？');
        if (ok) {
          let fn = prompt('保存するファイル名を入力してください（.gpxまで）', defaultGpxName());
          if (fn) {
            fn = fn.trim();
            if (!fn.toLowerCase().endsWith('.gpx')) fn += '.gpx';
            const gpx = buildGpx();
            await saveTextFileInteractively(fn, gpx);
          }
        }
      }
    }

    startBtn.addEventListener('click', startTracking);
    stopBtn.addEventListener('click', stopTracking);
    fabStop.addEventListener('click', stopTracking);

    recenterBtn.addEventListener('click', ()=>{
      if (lastPos) map.setView([lastPos.lat, lastPos.lon]);
    });

    // チェックポイント（メモ入力）
    const cpLayer = L.layerGroup().addTo(map);
    cpBtn.addEventListener('click', ()=>{
      if (!lastPos) return;
      const memo = window.prompt('チェックポイントのメモ（任意）を入力');
      const p = { lat:lastPos.lat, lon:lastPos.lon, time:new Date().toISOString(), memo: memo || '' };
      cpList.push(p);
      const m = L.circleMarker([p.lat, p.lon], {
        radius:6, color:'#a00', weight:2, fillColor:'#f66', fillOpacity:0.9
      }).addTo(cpLayer);
      const label = p.memo ? (`メモ: ${p.memo}`) : 'チェックポイント';
      m.bindPopup(`${label}<br>${new Date(p.time).toLocaleString()}`);
      speak('チェックポイント。');
    });

    /* ===== GPX 生成 & 保存（終了時に実行） ===== */
    function defaultGpxName(){
      const d = new Date();
      return `route_${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}.gpx`;
    }
    function buildGpx(){
      // CPをwpt、走行軌跡をtrkとして出力
      const header =
        `<?xml version="1.0" encoding="UTF-8"?>\n`+
        `<gpx version="1.1" creator="RouteHelper" xmlns="http://www.topografix.com/GPX/1/1">\n`;
      const wpts = cpList.map(cp =>
        `<wpt lat="${cp.lat}" lon="${cp.lon}">`+
          (cp.time ? `<time>${cp.time}</time>` : '') +
          (cp.memo ? `<name>${escapeXml(cp.memo)}</name>` : '') +
        `</wpt>`
      ).join('');
      const trk =
        `<trk><name>track</name><trkseg>`+
        points.map(p=>`<trkpt lat="${p.lat}" lon="${p.lon}"><time>${p.time}</time></trkpt>`).join('')+
        `</trkseg></trk>`;
      return header + wpts + trk + `</gpx>`;
    }
    function escapeXml(s){ return s.replace(/[<>&'"]/g, c=>({ '<':'&lt;','>':'&gt;','&':'&amp;','\'':'&apos;','"':'&quot;' }[c])); }

    async function saveTextFileInteractively(defaultName, text){
      const blob = new Blob([text], {type:'application/gpx+xml'});
      if (window.showSaveFilePicker){
        try{
          const handle = await window.showSaveFilePicker({
            suggestedName: defaultName,
            types:[{description:'GPX file', accept:{'application/gpx+xml':['.gpx']}}]
          });
          const writable = await handle.createWritable();
          await writable.write(blob); await writable.close();
          alert('保存しました（指定場所）');
          return;
        }catch(e){ /* キャンセル等はフォールバック */ }
      }
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob); a.download=defaultName||'track.gpx';
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
      alert('保存しました（ダウンロード）');
    }

    /* ===== POI 読み上げ（近傍優先 & 初期まとめ読み） ===== */
    const notifyRangeInput=document.getElementById('notifyRange');
    const notifyRangeVal=document.getElementById('notifyRangeVal');
    notifyRangeInput.addEventListener('input',()=>{ notifyRangeVal.textContent=notifyRangeInput.value; });

    const poiList=[];
    function htmlToPlain(html){
      if(!html) return '';
      const el=document.createElement('div'); el.innerHTML=html;
      return (el.textContent||el.innerText||'').replace(/\s+/g,' ').trim();
    }
    function collectPOIsFromGeoJSON(gj){
      (gj.features||[]).forEach(f=>{
        if(!f||!f.geometry) return;
        const props=f.properties||{};
        if(f.geometry.type==='Point'){
          const [lon,lat]=f.geometry.coordinates;
          poiList.push({lat,lon,title:props.name||props.Title||'', memo:htmlToPlain(props.description||props.Description), notified:false});
        } else if (f.geometry.type==='GeometryCollection' && Array.isArray(f.geometry.geometries)){
          f.geometry.geometries.forEach(g=>{
            if(g.type==='Point'){
              const [lon,lat]=g.coordinates;
              poiList.push({lat,lon,title:props.name||props.Title||'', memo:htmlToPlain(props.description||props.Description), notified:false});
            }
          });
        }
      });
    }
    function haversineMeters(lat1,lon1,lat2,lon2){
      const R=6371000,toRad=x=>x*Math.PI/180;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    // 通常走行中：半径内の最寄り1件（クールダウン）
    let lastSpeakAt=0; const MIN_SPEAK_INTERVAL_MS=5000;
    function maybeAnnounceNearestPOI(lat,lon){
      if (initialAnnouncing) return; // 初期まとめ読み上げ中は抑止
      const range=parseFloat(notifyRangeInput.value||'120');
      const candidates=poiList
        .filter(p=>!p.notified && haversineMeters(lat,lon,p.lat,p.lon)<=range)
        .map(p=>({p,d:haversineMeters(lat,lon,p.lat,p.lon)}))
        .sort((a,b)=>a.d-b.d);
      if(!candidates.length) return;
      const now=Date.now(); if(now-lastSpeakAt<MIN_SPEAK_INTERVAL_MS) return;
      const nearest=candidates[0].p; const d=Math.round(candidates[0].d);
      const text=[nearest.title, nearest.memo].filter(Boolean).join('。');
      speak((text||'評価ポイント')+`。距離 ${d} メートル。`);
      nearest.notified=true; lastSpeakAt=now;
    }

    // 初期まとめ読み上げ：半径内の全件を近い順に（1回だけ）
    function getInRangeSorted(lat, lon){
      const range=parseFloat(notifyRangeInput.value||'120');
      return poiList
        .filter(p=>!p.notified && haversineMeters(lat,lon,p.lat,p.lon)<=range)
        .map(p=>({p,d:haversineMeters(lat,lon,p.lat,p.lon)}))
        .sort((a,b)=>a.d-b.d);
    }
    function speakQueue(lines, done){
      const next = () => {
        if (!lines.length){ if(done) done(); return; }
        const t = lines.shift();
        speak(t, ()=> setTimeout(next, 200)); // 0.2秒間隔
      };
      next();
    }
    function tryAnnounceInitialOnce(){
      if (initialAnnounced || !lastPos || !poiList.length) return;
      const list = getInRangeSorted(lastPos.lat, lastPos.lon);
      if (!list.length){ initialAnnounced = true; return; }
      initialAnnouncing = true;
      const msgs = list.map(({p,d})=>{
        p.notified = true; // 二重読み上げ防止
        const txt=[p.title, p.memo].filter(Boolean).join('。');
        return (txt||'評価ポイント')+`。距離 ${Math.round(d)} メートル。`;
      });
      speakQueue(msgs, ()=>{
        initialAnnouncing = false;
        initialAnnounced  = true;
        lastSpeakAt = Date.now(); // 直後の通常読み上げとの競合防止
      });
    }
    function ensurePositionThenAnnounce(){
      if (lastPos){ tryAnnounceInitialOnce(); return; }
      if (navigator.geolocation?.getCurrentPosition){
        navigator.geolocation.getCurrentPosition(p=>{
          lastPos = { lat:p.coords.latitude, lon:p.coords.longitude };
          tryAnnounceInitialOnce();
        }, ()=>{/* ignore */}, { enableHighAccuracy:true, timeout:5000 });
      }
    }

    /* ===== KML/KMZ 読み込み & セレクト ===== */
    const fileInput=document.getElementById('file');
    const datasetSelect=document.getElementById('datasetSelect');
    const placeholderOpt = datasetSelect.querySelector('option[value=""]');
    const datasetsByValue = new Map(); // value -> {name, layer}

    function activateDatasetSelect(){
      if (placeholderOpt){ placeholderOpt.disabled = true; placeholderOpt.selected = false; }
      if (datasetSelect.options.length > 1 && datasetSelect.selectedIndex === 0){
        datasetSelect.selectedIndex = 1;
        datasetSelect.dispatchEvent(new Event('change'));
      }
    }

    fileInput.addEventListener('change', async e=>{
      const files=Array.from(e.target.files||[]);
      for(const f of files){
        if(f.name.toLowerCase().endsWith('.kml')){
          const txt=await f.text();
          const dom=new DOMParser().parseFromString(txt,'text/xml');
          const gj=toGeoJSON.kml(dom);
          addDataset(f.name, gj);
        } else if (f.name.toLowerCase().endsWith('.kmz')){
          const zip=await JSZip.loadAsync(await f.arrayBuffer());
          const kmlEntry=zip.file(/\.kml$/i)[0];
          if(kmlEntry){
            const txt=await kmlEntry.async('text');
            const dom=new DOMParser().parseFromString(txt,'text/xml');
            const gj=toGeoJSON.kml(dom);
            addDataset(f.name.replace(/\.kmz$/i,'.kml'), gj);
          }
        }
      }
      // ファイル読込後にも初期判定（読み込み先→位置先の順でも動く）
      tryAnnounceInitialOnce();
    });

    function addDataset(name, gj){
      const layer=L.geoJSON(gj,{
        style:{ color:'#0066cc', weight:3 },
        pointToLayer:(feat,latlng)=>L.circleMarker(latlng,{ radius:6, color:'#0066cc', weight:2, fillColor:'#66aaff', fillOpacity:0.9 })
      }).addTo(map);

      if (layer.getBounds && layer.getBounds().isValid()){
        map.fitBounds(layer.getBounds(), {padding:[20,20]});
      }

      const value = `${name}__${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
      const opt=document.createElement('option');
      opt.value=value; opt.textContent=name;
      datasetSelect.appendChild(opt);
      datasetsByValue.set(value, {name, layer});

      activateDatasetSelect();
      collectPOIsFromGeoJSON(gj);

      // 追加直後にも初期判定（位置が既に来ていれば即アナウンス）
      tryAnnounceInitialOnce();
    }

    datasetSelect.addEventListener('change', ()=>{
      const selValue = datasetSelect.value;
      datasetsByValue.forEach(({layer}, v)=>{
        if (layer.setStyle) layer.setStyle({opacity: v===selValue ? 1 : 0.35});
      });
    });

    /* ===== 画面オフ防止 ===== */
    const wakeBtn=document.getElementById('wake'); let wakeLock=null;
    async function toggleWake(){
      if(!wakeLock){
        try{ wakeLock=await navigator.wakeLock.request('screen'); wakeBtn.textContent='画面オフ防止: ON'; }
        catch(e){ alert('この端末/ブラウザは画面オフ防止に対応していない可能性があります。'); }
      }else{
        try{ await wakeLock.release(); }catch(e){}
        wakeLock=null; wakeBtn.textContent='画面オフ防止: OFF';
      }
    }
    wakeBtn.addEventListener('click', toggleWake);

    // 起動時に1回だけ現在地を先取り（許可応答が遅い端末対策）
    if (navigator.geolocation?.getCurrentPosition){
      navigator.geolocation.getCurrentPosition(p=>{
        lastPos = { lat:p.coords.latitude, lon:p.coords.longitude };
        tryAnnounceInitialOnce();
      }, ()=>{}, { enableHighAccuracy:true, timeout:5000 });
    }

    // 初期状態
    updateCounts();
    updateHUD();

  }); // DOMContentLoaded
  </script>
</body>
</html>
