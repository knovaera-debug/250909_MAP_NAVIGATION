<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>実車評価支援ツール（初期近傍順読み上げ対応）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet：CDN -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>

  <style>
    html, body { height:100%; margin:0; }
    #map { position:absolute; inset:0; min-height:60vh; } /* 保険で高さ確保 */

    #panel{
      position:absolute; top:8px; left:8px; right:8px;
      background:#fff; padding:10px; border-radius:12px;
      box-shadow:0 2px 6px rgba(0,0,0,.3);
      z-index:1000; font-size:14px; max-width:560px;
    }
    h1{ margin:0 0 6px; font-size:14px; }
    .row{ display:flex; flex-wrap:wrap; gap:8px; margin:4px 0; align-items:center; }
    .grow{ flex:1; }
    button{ padding:6px 10px; border-radius:10px; border:1px solid #888; background:#f0f0f0; }
    #fabStop{ position:absolute; bottom:20px; right:20px; border-radius:50%; width:64px; height:64px; font-size:14px; font-weight:bold; background:red; color:#fff; display:none; z-index:1200; }
    .counts{ font-size:12px; margin-left:auto; }
    .small{ font-size:12px; color:#333; }

    @media (max-width:480px){
      #panel{ padding:8px 10px; border-radius:10px; font-size:12px; }
      h1{ font-size:13px; }
      button{ padding:6px 8px; min-height:32px; font-size:12px; }
      .row{ gap:6px; }
      .row.row-actions{ display:grid; grid-template-columns:1fr 1fr; gap:6px; }
      #fname{ display:none; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <h1>実車評価支援ツール</h1>

    <div class="row">
      <input type="file" id="file" accept=".kml,.kmz" multiple />
      <select id="datasetSelect" class="grow">
        <option value="" disabled selected>（読み込んだルート／ポイントを選択）</option>
      </select>
      <span id="fname" class="small"></span>
    </div>

    <div class="row row-actions">
      <button id="start">追跡開始</button>
      <button id="stop" disabled>追跡終了</button>
      <button id="recenter">現在地へ</button>
      <button id="cp" disabled>チェックポイント</button>
      <span id="counts" class="counts"></span>
    </div>

    <details id="adv" open>
      <summary class="small">詳細設定</summary>

      <div class="row">
        <label><input type="checkbox" id="keepCentered" checked />自車を常に中心</label>
        <label style="margin-left:10px">向き:</label>
        <label><input type="radio" name="orient" value="north" checked />北を上</label>
        <label><input type="radio" name="orient" value="course" />進行方向を上</label>
      </div>

      <div class="row">
        <button id="tts">音声テスト</button>
        <!-- 端末側（iPhone等）で好きな声を選べるよう、強制はしない -->
        <select id="voiceSelect" class="small" style="min-width:200px"></select>
        <button id="wake">画面オフ防止: OFF</button>
      </div>

      <div class="row">
        <label class="small" for="ttsRate">話す速度: <span id="ttsRateVal">1.0</span>x</label>
        <input id="ttsRate" type="range" min="0.6" max="1.6" step="0.1" value="1.0" style="width:180px; margin-left:8px;">
      </div>

      <div class="row">
        <label class="small" for="notifyRange">通知半径: <span id="notifyRangeVal">120</span> m</label>
        <input id="notifyRange" type="range" min="50" max="300" step="10" value="120" style="width:180px; margin-left:8px;">
      </div>

      <div class="row">
        <input id="gpxName" type="text" placeholder="ファイル名（例: route_YYYYMMDD.gpx）" style="min-width:220px;" />
        <button id="saveGpx" disabled>GPX保存</button>
        <span id="stat" class="small"></span>
      </div>
    </details>
  </div>

  <button id="fabStop">終了</button>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="jszip.min.js"></script>
  <script src="togeojson.umd.js"></script>

  <script>
  document.addEventListener('DOMContentLoaded', function(){

    /* ===== 地図 ===== */
    const map = L.map('map').setView([35.0, 135.0], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // 自車マーカー（赤塗り）
    const carIcon = L.divIcon({
      className: 'custom-car',
      html: '<div style="width:16px;height:16px;background:red;border-radius:50%;"></div>',
      iconSize: [16,16], iconAnchor: [8,8]
    });
    const carMarker = L.marker([35.0, 135.0], {icon:carIcon}).addTo(map);

    /* ===== TTS ===== */
    const ttsRate = document.getElementById('ttsRate');
    const ttsRateVal = document.getElementById('ttsRateVal');
    const voiceSelect = document.getElementById('voiceSelect');

    let voicesCache = [];
    let selectedVoice = null;
    function populateVoiceSelect(){
      voicesCache = speechSynthesis.getVoices();
      if (!voicesCache.length) return;
      const saved = localStorage.getItem('voiceName');
      selectedVoice = voicesCache.find(v => v.name === saved) || voicesCache[0];
      voiceSelect.innerHTML = '';
      voicesCache.forEach(v=>{
        const o=document.createElement('option');
        o.value=v.name; o.textContent=`${v.name} (${v.lang})`;
        if (selectedVoice && v.name===selectedVoice.name) o.selected=true;
        voiceSelect.appendChild(o);
      });
    }
    function speak(text, onend){
      const u = new SpeechSynthesisUtterance(text);
      if (!voicesCache.length) populateVoiceSelect();
      if (selectedVoice) u.voice = selectedVoice;
      u.rate = parseFloat(ttsRate.value || '1.0');
      if (onend) u.onend = onend;
      speechSynthesis.speak(u);
    }
    voiceSelect.addEventListener('change', ()=>{
      const name = voiceSelect.value;
      selectedVoice = (speechSynthesis.getVoices()||[]).find(v=>v.name===name) || selectedVoice;
      localStorage.setItem('voiceName', name);
    });
    speechSynthesis.onvoiceschanged = populateVoiceSelect;
    setTimeout(populateVoiceSelect, 300);
    document.getElementById('tts').addEventListener('click', ()=>{ if (!voicesCache.length) populateVoiceSelect(); speak('音声テストです。'); });
    ttsRate.addEventListener('input', ()=>{ ttsRateVal.textContent = ttsRate.value; });

    /* ===== 追跡 ===== */
    let watching = null;
    let tracking = false;
    let points = [];
    let lastPos = null;                    // ★ 直近位置
    const poly = L.polyline([], { color:'#d00', weight:4 }).addTo(map);

    const startBtn = document.getElementById('start');
    const stopBtn  = document.getElementById('stop');
    const fabStop  = document.getElementById('fabStop');
    const recenterBtn = document.getElementById('recenter');
    const cpBtn = document.getElementById('cp');
    const keepCentered = document.getElementById('keepCentered');
    const counts = document.getElementById('counts');
    function updateCounts(){ counts.textContent = `点:${points.length}`; }

    function onLoc(pos){
      const { latitude:lat, longitude:lon } = pos.coords;
      lastPos = {lat, lon};                // ★ 更新
      const now = new Date();
      carMarker.setLatLng([lat, lon]);
      if (tracking){
        points.push({lat, lon, time: now.toISOString()});
        poly.addLatLng([lat, lon]);
        updateCounts();
      }
      if (keepCentered.checked) map.setView([lat, lon]);
      maybeAnnounceNearestPOI(lat, lon);   // 走行中は最寄りを都度読む
    }
    function onLocErr(err){ console.warn(err); }

    function startTracking(){
      if (tracking) return;
      tracking = true;
      startBtn.disabled = true; stopBtn.disabled = false; cpBtn.disabled = false;
      fabStop.style.display = 'block';
      speak('追跡を開始します。', ()=> {
        // 初期に半径内に既にあるポイントを、近い順でまとめて読み上げ
        announceInitialPOIsInRange();
      });
      if (!watching) watching = navigator.geolocation.watchPosition(onLoc, onLocErr, { enableHighAccuracy:true, maximumAge:2000, timeout:10000 });
      document.getElementById('adv').open = false;
    }
    function stopTracking(){
      if (!tracking) return;
      tracking = false;
      startBtn.disabled = false; stopBtn.disabled = true; cpBtn.disabled = true;
      fabStop.style.display = 'none';
      speak('追跡を終了しました。');
      document.getElementById('saveGpx').disabled = points.length === 0;
      document.getElementById('adv').open = true;
      updateCounts();
    }
    startBtn.addEventListener('click', startTracking);
    stopBtn.addEventListener('click', stopTracking);
    fabStop.addEventListener('click', stopTracking);

    recenterBtn.addEventListener('click', ()=>{
      if (lastPos) map.setView([lastPos.lat, lastPos.lon]);
    });

    // チェックポイント
    const cpLayer = L.layerGroup().addTo(map);
    cpBtn.addEventListener('click', ()=>{
      if (!lastPos) return;
      L.circleMarker([lastPos.lat, lastPos.lon], { radius:6, color:'#a00', weight:2, fillColor:'#f66', fillOpacity:0.9 }).addTo(cpLayer);
      speak('チェックポイント。');
    });

    /* ===== GPX 生成 & 保存 ===== */
    function buildGpx(){
      if (!points.length) return '';
      const header =
        `<?xml version="1.0" encoding="UTF-8"?>\n`+
        `<gpx version="1.1" creator="RouteHelper" xmlns="http://www.topografix.com/GPX/1/1">\n`+
        `<trk><name>track</name><trkseg>`;
      const body = points.map(p=>`<trkpt lat="${p.lat}" lon="${p.lon}"><time>${p.time}</time></trkpt>`).join('');
      return header + body + `</trkseg></trk></gpx>`;
    }
    async function saveTextFileInteractively(defaultName, text){
      const blob = new Blob([text], {type:'application/gpx+xml'});
      if (window.showSaveFilePicker){
        try{
          const handle = await window.showSaveFilePicker({
            suggestedName: defaultName,
            types:[{description:'GPX file', accept:{'application/gpx+xml':['.gpx']}}]
          });
          const writable = await handle.createWritable();
          await writable.write(blob); await writable.close();
          return {ok:true, method:'fs-access'};
        }catch(e){}
      }
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob); a.download=defaultName||'track.gpx';
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
      return {ok:true, method:'download'};
    }
    const saveBtn=document.getElementById('saveGpx');
    const nameInput=document.getElementById('gpxName');
    saveBtn.addEventListener('click', async ()=>{
      const gpx=buildGpx();
      if(!gpx){ alert('GPXデータがありません'); return; }
      let fn=(nameInput && nameInput.value.trim())||'';
      if(!fn){
        const d=new Date();
        fn=`route_${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}.gpx`;
        if(nameInput) nameInput.value=fn;
      }
      if(!fn.toLowerCase().endsWith('.gpx')) fn+='.gpx';
      const res=await saveTextFileInteractively(fn,gpx);
      const stat=document.getElementById('stat');
      if(stat){
        stat.textContent=res.method==='fs-access'?'保存しました（指定場所）':'保存しました（ダウンロード）';
        setTimeout(()=>stat.textContent='',3000);
      }
    });

    /* ===== POI 読み上げ（タイトル＋メモ） ===== */
    const notifyRangeInput=document.getElementById('notifyRange');
    const notifyRangeVal=document.getElementById('notifyRangeVal');
    notifyRangeInput.addEventListener('input',()=>{ notifyRangeVal.textContent=notifyRangeInput.value; });

    const poiList=[];
    function htmlToPlain(html){
      if(!html) return '';
      const el=document.createElement('div'); el.innerHTML=html;
      return (el.textContent||el.innerText||'').replace(/\s+/g,' ').trim();
    }
    function collectPOIsFromGeoJSON(gj){
      (gj.features||[]).forEach(f=>{
        if(!f||!f.geometry) return;
        const props=f.properties||{};
        if(f.geometry.type==='Point'){
          const [lon,lat]=f.geometry.coordinates;
          poiList.push({lat,lon,title:props.name||props.Title||'', memo:htmlToPlain(props.description||props.Description), notified:false});
        } else if (f.geometry.type==='GeometryCollection' && Array.isArray(f.geometry.geometries)){
          f.geometry.geometries.forEach(g=>{
            if(g.type==='Point'){
              const [lon,lat]=g.coordinates;
              poiList.push({lat,lon,title:props.name||props.Title||'', memo:htmlToPlain(props.description||props.Description), notified:false});
            }
          });
        }
      });
    }
    function haversineMeters(lat1,lon1,lat2,lon2){
      const R=6371000,toRad=x=>x*Math.PI/180;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    // 走行中の単発アナウンス（最寄り1件）
    let lastSpeakAt=0; const MIN_SPEAK_INTERVAL_MS=5000;
    function maybeAnnounceNearestPOI(lat,lon){
      const range=parseFloat(notifyRangeInput.value||'120');
      const candidates=poiList
        .filter(p=>!p.notified && haversineMeters(lat,lon,p.lat,p.lon)<=range)
        .map(p=>({p,d:haversineMeters(lat,lon,p.lat,p.lon)}))
        .sort((a,b)=>a.d-b.d);
      if(!candidates.length) return;
      const now=Date.now(); if(now-lastSpeakAt<MIN_SPEAK_INTERVAL_MS) return;
      const nearest=candidates[0].p; const d=Math.round(candidates[0].d);
      const text=[nearest.title, nearest.memo].filter(Boolean).join('。');
      speak((text||'評価ポイント')+`。距離 ${d} メートル。`);
      nearest.notified=true; lastSpeakAt=now;
    }

    // ★ 初期に半径内へ既に入っているものを「近い順に全部」読む
    function getInRangeSorted(lat, lon){
      const range=parseFloat(notifyRangeInput.value||'120');
      return poiList
        .filter(p=>!p.notified && haversineMeters(lat,lon,p.lat,p.lon)<=range)
        .map(p=>({p,d:haversineMeters(lat,lon,p.lat,p.lon)}))
        .sort((a,b)=>a.d-b.d);
    }
    function speakQueue(texts){
      const next = () => {
        if (!texts.length) return;
        const t = texts.shift();
        speak(t, () => setTimeout(next, 250)); // 0.25秒間隔で次へ
      };
      next();
    }
    function announceInitialPOIsInRange(){
      if (!lastPos) return;
      const list = getInRangeSorted(lastPos.lat, lastPos.lon);
      if (!list.length) return;
      const msgs = list.map(({p,d})=>{
        p.notified = true; // 重複防止
        const txt=[p.title, p.memo].filter(Boolean).join('。');
        return (txt||'評価ポイント')+`。距離 ${Math.round(d)} メートル。`;
      });
      lastSpeakAt = Date.now(); // 直後の二重読み上げを防止
      speakQueue(msgs);
    }

    /* ===== KML/KMZ 読み込み & セレクト ===== */
    const fileInput=document.getElementById('file');
    const datasetSelect=document.getElementById('datasetSelect');
    const placeholderOpt = datasetSelect.querySelector('option[value=""]');
    const datasetsByValue = new Map(); // value -> {name, layer}

    function activateDatasetSelect(){
      if (placeholderOpt){ placeholderOpt.disabled = true; placeholderOpt.selected = false; }
      if (datasetSelect.options.length > 1 && datasetSelect.selectedIndex === 0){
        datasetSelect.selectedIndex = 1;
        datasetSelect.dispatchEvent(new Event('change'));
      }
    }

    fileInput.addEventListener('change', async e=>{
      const files=Array.from(e.target.files||[]);
      for(const f of files){
        if(f.name.toLowerCase().endsWith('.kml')){
          const txt=await f.text();
          const dom=new DOMParser().parseFromString(txt,'text/xml');
          const gj=toGeoJSON.kml(dom);
          addDataset(f.name, gj);
        } else if (f.name.toLowerCase().endsWith('.kmz')){
          const zip=await JSZip.loadAsync(await f.arrayBuffer());
          const kmlEntry=zip.file(/\.kml$/i)[0];
          if(kmlEntry){
            const txt=await kmlEntry.async('text');
            const dom=new DOMParser().parseFromString(txt,'text/xml');
            const gj=toGeoJSON.kml(dom);
            addDataset(f.name.replace(/\.kmz$/i,'.kml'), gj);
          }
        }
      }
      // ファイル読込直後にも（初期判定）
      announceInitialPOIsInRange();
    });

    function addDataset(name, gj){
      const layer=L.geoJSON(gj,{
        style:{ color:'#0066cc', weight:3 },
        pointToLayer:(feat,latlng)=>L.circleMarker(latlng,{ radius:6, color:'#0066cc', weight:2, fillColor:'#66aaff', fillOpacity:0.9 })
      }).addTo(map);

      if (layer.getBounds && layer.getBounds().isValid()){
        map.fitBounds(layer.getBounds(), {padding:[20,20]});
      }

      // セレクトへ（value は一意）
      const value = `${name}__${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
      const opt=document.createElement('option');
      opt.value=value; opt.textContent=name;
      datasetSelect.appendChild(opt);
      datasetsByValue.set(value, {name, layer});

      activateDatasetSelect();
      collectPOIsFromGeoJSON(gj);
    }

    datasetSelect.addEventListener('change', ()=>{
      const selValue = datasetSelect.value;
      datasetsByValue.forEach(({layer}, v)=>{
        if (layer.setStyle) layer.setStyle({opacity: v===selValue ? 1 : 0.35});
      });
    });

    /* ===== 画面オフ防止 ===== */
    const wakeBtn=document.getElementById('wake'); let wakeLock=null;
    async function toggleWake(){
      if(!wakeLock){
        try{ wakeLock=await navigator.wakeLock.request('screen'); wakeBtn.textContent='画面オフ防止: ON'; }
        catch(e){ alert('この端末/ブラウザは画面オフ防止に対応していない可能性があります。'); }
      }else{
        try{ await wakeLock.release(); }catch(e){}
        wakeLock=null; wakeBtn.textContent='画面オフ防止: OFF';
      }
    }
    wakeBtn.addEventListener('click', toggleWake);

    // 初期状態
    document.getElementById('saveGpx').disabled = true;
    updateCounts();

    // 起動時に1回だけ現在地を取得して lastPos を先に持っておく（任意）
    if (navigator.geolocation?.getCurrentPosition){
      navigator.geolocation.getCurrentPosition(p=>{
        lastPos = { lat:p.coords.latitude, lon:p.coords.longitude };
      }, ()=>{}, { enableHighAccuracy:true, timeout:5000 });
    }

  }); // DOMContentLoaded
  </script>
</body>
</html>
